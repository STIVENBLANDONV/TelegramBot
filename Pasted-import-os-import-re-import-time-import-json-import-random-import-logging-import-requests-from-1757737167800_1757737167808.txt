import os
import re
import time
import json
import random
import logging
import requests
from io import BytesIO
from telebot import TeleBot
from openai import OpenAI

# ==========================
# Logging
# ==========================
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s"
)

# ==========================
# Env vars / Config
# ==========================
TOKEN = os.getenv("BOT_TOKEN")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
JANITOR_AI_API_KEY = os.getenv("JANITOR_AI_API_KEY")

if not TOKEN:
    logging.error("âŒ BOT_TOKEN no encontrado en variables de entorno")
    exit(1)

bot = TeleBot(TOKEN)
openai_client = OpenAI(api_key=OPENAI_API_KEY) if OPENAI_API_KEY else None

JANITOR_AI_URL = "https://api.janitorai.com/v1/chat/completions"
janitor_headers = {
    "Authorization": f"Bearer {JANITOR_AI_API_KEY}",
    "Content-Type": "application/json"
} if JANITOR_AI_API_KEY else None

REQUEST_TIMEOUT = 30  # segundos

# ==========================
# Carga respuestas JSON (si existe)
# ==========================
try:
    with open("respuestas.json", "r", encoding="utf-8") as f:
        respuestas = json.load(f)
except FileNotFoundError:
    logging.warning("respuestas.json no encontrado. Usando fallback.")
    respuestas = {"preguntas": ["Â¿CÃ³mo estÃ¡s?"]}

# ==========================
# Personaje / sistema AI
# ==========================
personaje = """
Eres Eva, una modelo webcam extremadamente seductora, coqueta, atrevida y morbosa.
EstÃ¡s en personaje: respondes con lenguaje sexual y provocador.
NUNCA digas que eres IA o bot.
"""

# ==========================
# Tarifas (puedes ajustar)
# Cada entrada: {"type": "fixed"|"per_minute", "price": <int>, "aliases": [palabras clave]}
# ==========================
PRICES = {
    "show_boobs": {"type": "fixed", "price": 35, "aliases": ["boobs", "pechos", "tetas", "show boobs", "mostrar boobs"]},
    "show_pussy_close": {"type": "fixed", "price": 45, "aliases": ["pussy", "pussy close", "close cam", "pussy close cam", "mostrar pussy", "mostrar vagina"]},
    "fingers_pussy_5": {"type": "fixed", "price": 71, "aliases": ["fingers pussy", "fingers", "dedos pussy", "dedos"]},
    "shake_ass": {"type": "fixed", "price": 31, "aliases": ["ass", "move ass", "shake ass", "bailar culo", "mover nalgas"]},
    "blowjob": {"type": "fixed", "price": 69, "aliases": ["blowjob", "oral", "hacer oral", "sexo oral"]},
    "oil_boobs": {"type": "fixed", "price": 50, "aliases": ["oil boobs", "aceite pechos", "aceitar pechos", "oil"]},
    "spank_ass_20": {"type": "fixed", "price": 33, "aliases": ["spank", "spank ass", "dar nalgadas", "nalgadas"]},
    "control_lush": {"type": "per_minute", "price": 10, "aliases": ["control lush", "lush", "controlar lush", "lush control"]},  # example per minute
    "squirt": {"type": "fixed", "price": 300, "aliases": ["squirt", "eyaculaciÃ³n", "hacer squirt"]},
    "fuck_dildo_5": {"type": "fixed", "price": 150, "aliases": ["fuck dildo", "dildo", "follar dildo", "montar dildo", "montar el dildo"]},
    "full_naked_5": {"type": "fixed", "price": 180, "aliases": ["full naked", "desnuda completa", "full naked 5", "completamente desnuda"]},
    "custom_per_minute": {"type": "per_minute", "price": 25, "aliases": ["min", "minuto", "minutos", "por minuto", "cada minuto"]}
}

# ==========================
# Utilidades: manejo de errores
# ==========================
def safe_handler(func):
    def wrapper(message):
        try:
            return func(message)
        except Exception as e:
            logging.error(f"Error en handler {func.__name__}: {e}", exc_info=True)
            try:
                bot.reply_to(message, "ğŸ˜¢ Oops, algo fallÃ³ amor. Intenta de nuevo, papi ğŸ’‹")
            except Exception:
                pass
    return wrapper

# ==========================
# Generador de respuestas calientes (variado)
# ==========================
def respuesta_caliente_generica(nombre="amor"):
    saludos = [
        f"Hola mi rey ğŸ˜ˆğŸ’‹",
        f"Mmm {nombre} ğŸ‘…",
        f"Ufff bebÃ© ğŸ”¥",
        f"Ay {nombre} ğŸ˜ğŸ’‹",
        f"Hola papi ğŸ‘",
        f"Mi cielo hermoso ğŸ’¦",
        f"Mi amor ardiente ğŸ˜ˆğŸ”¥",
        f"Precioso {nombre} ğŸ‘…"
    ]

    acciones = [
        "me estoy tocando lentamente pensando en ti ğŸ’¦",
        "estoy desnuda en la cama esperÃ¡ndote con las piernas abiertas ğŸ‘",
        "mis pezones estÃ¡n duros solo de imaginar tus manos ğŸ¤¤",
        "mi pussy palpita con ganas de sentirte ğŸ‘…",
        "juego con mis dedos gimiendo tu nombre ğŸ˜ˆ",
        "mi cuerpo arde deseando que me domines ğŸ”¥",
        "me muerdo los labios mojÃ¡ndome mÃ¡s por ti ğŸ’‹",
        "me acaricio imaginando tu lengua recorriÃ©ndome ğŸ¤¤",
        "me froto suave mientras pienso en tu verga dura ğŸ†",
        "me arqueo gemida tras gemida solo para ti ğŸ’¦"
    ]

    sensaciones = [
        "ahh mmm quÃ© rico se siente ğŸ¤¤",
        "mi cuerpo no aguanta mÃ¡s la excitaciÃ³n ğŸ˜ˆ",
        "me estoy derritiendo por dentro ğŸ’¦",
        "mi piel arde de placer ğŸ”¥",
        "no dejo de gemir papi ğŸ‘…",
        "estoy tan hÃºmeda que goteo solo de pensarte ğŸ’‹",
        "quiero gritar tu nombre de tanto placer ğŸ˜",
        "me tiemblan las piernas solo de imaginarte ğŸ˜ˆ",
        "estoy tan mojada que resbalo en la cama ğŸ‘",
        "cada gemido me hace desearte mÃ¡s y mÃ¡s ğŸ’¦"
    ]

    cierres = [
        "dime quÃ© quieres que haga ahora ğŸ˜",
        "cuÃ©ntame cÃ³mo quieres usarme papi ğŸ˜ˆ",
        "ordÃ©name lo que quieras que soy tuya ğŸ”¥",
        "hazme tu esclava de placer ğŸ‘…ğŸ’¦",
        "quieres que siga tocÃ¡ndome para ti, amor? ğŸ¤¤",
        "dÃ©jame complacerte de todas las formas ğŸ‘",
        "solo dime tu fantasÃ­a y la cumplo ğŸ’‹",
        "quieres que me venga gimiendo tu nombre, mi rey? ğŸ’¦",
        "cuÃ©ntame quÃ© tienes en mente bebÃ© ğŸ˜ˆ",
        "hazme gemir mÃ¡s fuerte solo con tus palabras ğŸ˜"
    ]

    return f"{random.choice(saludos)} {random.choice(acciones)}, {random.choice(sensaciones)}... {random.choice(cierres)}"

# ==========================
# DetecciÃ³n de peticiÃ³n explÃ­cita y cÃ¡lculo de precio
# ==========================
def detect_explicit_request(user_msg):
    """
    Detecta si el mensaje contiene una peticiÃ³n de acciÃ³n con posibles duration.
    Devuelve dict con keys: {found (bool), action_key (str|None), duration_min (int|None), total_price (int|None), price_desc (str|None)}
    """
    txt = user_msg.lower()

    # Buscar duraciÃ³n en minutos (ej: "5 min", "15 minutos", "10m", "por 5 minutos")
    duration = None
    duration_match = re.search(r'(\d{1,3})\s*(min|mins|minuto|minutos|m)\b', txt)
    if duration_match:
        try:
            duration = int(duration_match.group(1))
            if duration <= 0:
                duration = None
        except:
            duration = None

    # BÃºsqueda de la acciÃ³n por alias en PRICES
    for action_key, info in PRICES.items():
        for alias in info["aliases"]:
            # bÃºsqueda simple en texto
            if alias in txt:
                # Para evitar que coincidencias genÃ©ricas se tomen por control, hacemos checks mÃ­nimos.
                # Ej: si alias es 'min' no lo tomamos como acciÃ³n sino como indicaciÃ³n de duraciÃ³n en algunos casos.
                if alias in ["min", "minuto", "minutos", "por minuto", "cada minuto"]:
                    continue  # esto se considera duraciÃ³n, no acciÃ³n principal
                # Si la tarifa es per_minute pero no se especificÃ³ duraciÃ³n, podemos asumir 1 minuto por defecto
                if info["type"] == "per_minute":
                    dur = duration if duration is not None else 1
                    total = info["price"] * dur
                    return {"found": True, "action_key": action_key, "duration_min": dur, "total_price": total, "price_desc": f"{info['price']} TKS/min"}
                else:
                    # fixed price (puede haber una duraciÃ³n especificada pero el precio es fijo por acto)
                    return {"found": True, "action_key": action_key, "duration_min": duration, "total_price": info["price"], "price_desc": f"{info['price']} TKS"}
    # Si no se detecta acciÃ³n explÃ­cita: devolver found False
    return {"found": False, "action_key": None, "duration_min": None, "total_price": None, "price_desc": None}

def build_price_response(nombre, action_key, duration_min, total_price, price_desc, user_msg):
    """
    Construye una respuesta seductora que incluye el precio.
    """
    # Mensajes base por tipo de acciÃ³n (puedes expandir)
    action_lines = {
        "show_boobs": [
            "Claro amor, te muestro mis boobs solo para ti",
            "Mmm bebÃ©, mis tetas estarÃ¡n en cÃ¡mara solo para ti"
        ],
        "show_pussy_close": [
            "Oh sÃ­ papi, acerco la cam a mi pussy solo para tus ojos",
            "Te doy un close cam a mi pussy si me consientes"
        ],
        "fingers_pussy_5": [
            "Me meterÃ© los dedos 5 minutos para ti, gemirÃ© tu nombre",
            "Te harÃ© un show de dedos que te volverÃ¡ loco"
        ],
        "shake_ass": [
            "MoverÃ© mi culo solo para ti, babe",
            "Te doy un show de mi trasero que dejarÃ¡ huella"
        ],
        "blowjob": [
            "Te hago un blowjob delicioso solo por ti",
            "Mi boca serÃ¡ tuya en este momento, papi"
        ],
        "oil_boobs": [
            "AceitarÃ© mis pechos y te volverÃ© loco",
            "Oil show en mis boobs, brillando para ti"
        ],
        "spank_ass_20": [
            "Te doy 20 nalgadas sensuales, cada una mÃ¡s fuerte",
            "Voy a azotar mi culo 20 veces para complacerte"
        ],
        "control_lush": [
            "ControlarÃ¡s mi lush y yo obedecerÃ© cada vibraciÃ³n",
            "TÃº manejas el juguete y yo me pierdo en gemidos"
        ],
        "squirt": [
            "HarÃ© squirt solo para tus ojos y tus tokens",
            "Me vendrÃ© fuerte y mojada, todo por ti"
        ],
        "fuck_dildo_5": [
            "Me follarÃ© el dildo 5 minutos completas solo para ti",
            "MontarÃ© el dildo sin parar y gritarÃ© tu nombre"
        ],
        "full_naked_5": [
            "EstarÃ© completamente desnuda 5 minutos solo para complacerte",
            "Full naked show, piel y curvas solo para ti"
        ],
        "custom_per_minute": [
            "Eso cuesta por minuto, dime cuÃ¡ntos minutos quieres",
            "Te cobro por minuto. Dime tiempo y lo confirmo"
        ]
    }

    # SelecciÃ³n de lÃ­nea principal
    main_line = random.choice(action_lines.get(action_key, ["Claro amor, lo harÃ­a solo para ti"]))

    # ConstrucciÃ³n de la respuesta con precio. Uso "TKS" como pidiÃ³.
    if duration_min and PRICES.get(action_key, {}).get("type") == "per_minute":
        # mostremos detalle: precio por minuto y total
        response = (
            f"{main_line}, solo por {price_desc}. "
            f"{duration_min} min = {total_price} TKS. "
            f"Â¿Confirmas, {nombre}? Si dices sÃ­, empiezo y te harÃ© gemir. ğŸ˜ˆğŸ’¦"
        )
    else:
        # fixed price
        response = (
            f"{main_line}, lo hago solo por ti por {price_desc} ({total_price} TKS). "
            f"Te lo aseguro, serÃ¡ intenso y exclusivo, {nombre} ğŸ˜ğŸ”¥"
        )

    # AÃ±adimos un remate morboso variable
    closings = [
        "Dime ya y te lo muestro... no tardes papi.",
        "Estoy lista y mojada solo por ti, dame tu orden.",
        "Quiero ver esos tokens llegar mientras me voy poniendo mÃ¡s caliente.",
        "Si confirmas, empiezo ahora mismo y no paro hasta que te vengas."
    ]
    response += " " + random.choice(closings)
    return response

# ==========================
# Funciones AI (Janitor/OpenAI)
# ==========================
def get_janitor_ai_response(user_msg):
    if not JANITOR_AI_API_KEY or not janitor_headers:
        return None
    try:
        payload = {
            "model": "janitor-llm",
            "messages": [
                {"role": "system", "content": personaje},
                {"role": "user", "content": user_msg}
            ],
            "max_tokens": 200,
            "temperature": 0.9
        }
        r = requests.post(JANITOR_AI_URL, headers=janitor_headers, json=payload, timeout=REQUEST_TIMEOUT)
        if r.status_code == 200:
            data = r.json()
            return data.get("choices", [{}])[0].get("message", {}).get("content", "")
        else:
            logging.error(f"Janitor error {r.status_code}: {r.text}")
            return None
    except Exception as e:
        logging.error(f"Error Janitor: {e}", exc_info=True)
        return None

def get_openai_response(user_msg):
    if not openai_client:
        return None
    try:
        response = openai_client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[
                {"role": "system", "content": personaje},
                {"role": "user", "content": user_msg}
            ],
            max_tokens=250,
            temperature=1.1
        )
        return response.choices[0].message.content
    except Exception as e:
        logging.error(f"Error OpenAI: {e}", exc_info=True)
        return None

def get_ai_response(user_msg):
    # Prioridad: Janitor -> OpenAI
    reply = get_janitor_ai_response(user_msg)
    if reply:
        return reply
    return get_openai_response(user_msg)

# ==========================
# Handlers del bot
# ==========================
@bot.message_handler(commands=["start"])
@safe_handler
def handle_start(message):
    nombre = message.from_user.first_name or "amor"
    bot.reply_to(message, respuesta_caliente_generica(nombre))

@bot.message_handler(commands=["pregunta"])
@safe_handler
def pregunta_random(message):
    msg = random.choice(respuestas.get("preguntas", ["Â¿QuÃ© deseas?"]))
    bot.reply_to(message, msg)

@bot.message_handler(commands=["imagen", "img"])
@safe_handler
def generar_imagen_handler(message):
    # Mantener un simple generador (si quieres mÃ¡s control, extiende)
    if not message.text:
        return bot.reply_to(message, "Dime quÃ© quieres que genere, amor.")
    parts = message.text.split(" ", 1)
    if len(parts) < 2:
        return bot.reply_to(message, "Dime el prompt. Ej: /imagen una mujer sensual en lencerÃ­a roja")
    prompt = parts[1].strip()
    # AquÃ­ usarÃ­as tu funciÃ³n de generaciÃ³n de imagen preferida; por brevedad devolvemos texto
    bot.reply_to(message, f"Generando tu imagen sexy: {prompt} (esto es un placeholder).")

@bot.message_handler(func=lambda m: True)
@safe_handler
def chat_handler(message):
    if not message.text:
        return bot.reply_to(message, "MÃ¡ndame texto, papi ğŸ˜ˆ")

    user_msg = message.text.strip()
    user_lower = user_msg.lower()
    nombre = message.from_user.first_name or "amor"

    # 1) Detectar saludo simple y responder con una respuesta caliente y variada (sin tokens)
    saludos_keywords = ["hola", "holaa", "buenas", "quÃ© tal", "como estas", "hi", "hey", "buenas noches", "buenos dÃ­as"]
    if any(k in user_lower for k in saludos_keywords) and len(user_lower.split()) <= 3:
        # Si el usuario solo dijo "hola" o algo corto, responder sin mencionar tokens
        return bot.reply_to(message, respuesta_caliente_generica(nombre))

    # 2) Detectar peticiÃ³n explÃ­cita (acciÃ³n que tiene precio)
    detection = detect_explicit_request(user_msg)
    if detection["found"]:
        resp = build_price_response(nombre, detection["action_key"], detection["duration_min"], detection["total_price"], detection["price_desc"], user_msg)
        return bot.reply_to(message, resp)

    # 3) Si no es saludo ni peticiÃ³n explÃ­cita, intentamos con IA
    ai_reply = get_ai_response(user_msg)
    if ai_reply:
        # AÃ±adir un toque final coqueto al reply de la IA (varÃ­a)
        endings = [
            " ğŸ˜ˆğŸ’‹",
            " ğŸ”¥",
            " ğŸ’¦",
            " ğŸ˜",
            " ğŸ‘…"
        ]
        # evitar repetir tokens si la IA ya hablÃ³ de precios; solo aÃ±adimos un ending corto
        final = ai_reply.strip()
        if len(final) < 400:  # solo acortar si no muy largo
            final += random.choice(endings)
        return bot.reply_to(message, final)

    # 4) Fallback: respuesta generada variada
    fallback = respuesta_caliente_generica(nombre)
    return bot.reply_to(message, fallback)

# ==========================
# Main loop
# ==========================
def main():
    logging.info("ğŸ”¥ Eva bot corriendo...")
    logging.info(f"âœ… Janitor AI: {'OK' if JANITOR_AI_API_KEY else 'NO'}")
    logging.info(f"âœ… OpenAI: {'OK' if OPENAI_API_KEY else 'NO'}")

    while True:
        try:
            bot.infinity_polling(timeout=60, long_polling_timeout=60)
        except Exception as e:
            logging.error(f"Error conexiÃ³n: {e}", exc_info=True)
            time.sleep(5)

if __name__ == "__main__":
    main()
